<!DOCTYPE html>
<html lang='en'  class='article'>
  <head>
    <meta charset='UTF-8'>
<meta http-equiv="Content-Type" content="text/html; charset="utf-8" >
<meta name=viewport content="width=device-width, minimum-scale=1.0">
<meta name="Description" content='Feed your head. Hack your world. Live curious. Neurogami.'  >
<meta name="keywords" content="Arizona, Phoenix, Scottsdale, Neurogami, Web, desktop, Arduino, Android, hardware, HCI, software, James Britt" >

    <title>Neurogami: 10 Minutes to Your First Ruby Application</title>
    <!-- COMMON STUFF -->
<!-- link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Anton" -->

<script  type="text/javascript" src='http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js' ></script>
<script type="text/javascript"  src="/js/styleswitcher.js"></script>

<style>

@font-face {
  font-family: 'Anton';
  font-style: normal;
  font-weight: normal;
  src: local('Anton'), url('/static/fonts/anton/v3/tilmJBBU81h1G7ZsdY3Hmw.woff') format('woff');
}

</style>


    <link rel='stylesheet' href='/css/grid.inuit.css'>
    <link rel='stylesheet' href='/css/keywords.inuit.css'>

    <link id='css' rel='stylesheet'           title='default' href='/css/style.css'>

    <link id='cssmono' rel='alternate stylesheet' title='mono'    href='/css/mono.css' >

        <link rel='stylesheet' href='/css/switch.css'>
        <link rel='stylesheet' href='/css/common.css'>

    <link rel="shortcut icon" href=/icon.png>
    <link rel="faveicon" href=/icon.png>
    <link rel='apple-touch-icon-precomposed' href='/icon.png' >

    <link rel="alternate" type="application/atom+xml" href="/feed/atom.xml" title="Atom 1.0">

  </head>
  <body class='wrapper' itemscope itemtype="http://schema.org/Article">

    <div class='grids' id='article' >
      <div class='grid-12'>
                

<div class='flush'>
<ul class='flat-menu'>

   <li><a href='/'>Home</a></li>



   <li><a href='/blog'>Blog</a></li>




  <li><a href='/code'>Code</a></li>

  

   <li><a href='/content'>Articles</a></li>


</ul>
</div>

        <h1 class='blog-title' itemprop='name' >10 Minutes to Your First Ruby Application</h1>
        <div class='blog-date'></div>
      </div>

      <div class='grid-1'>
        &#160;
      </div>

      <div class='grid-11' >

        
<style type='text/css'>
  .note {
    border: solid 2px #cc3300;
    padding: 10px;
    background-color: #FFFF00;

  }
  .whiteHeader {
    background-color: #dfdfdf;
  
    color: #FF0080; 
  }
  
    br { display:block; margin-top:10px; line-height:22px; }
  
</style>

    <div class='grids'>
      <p>By James Britt</p>
      <div class='note'>
        <p>2012-11: The code and article has been updated to fix some errors and to work with Ruby 1.9.3</p>
         <p>At the time it was written, and because of where it was originally published, it was targeted (more or less) at people working on Windows, so there may be a few unstated assumptions in the text.</p>
         <p>On the other hand, the command-line examples seem to reflect a unix shell, no doubt because that's where the bulk of the content was created.</p>
         <p>Apologies in advance for any confusion.</p>
      </div>

      <div class="abstract"><br>There's no better way to experience the elegance and power of Ruby than to fire up your code editor and start writing Ruby code. Create a small, useful Ruby application, and along the way, you'll learn what makes the language tick.</div>
      <br><br>
      So you've discovered the grace and power of Ruby and you're ready to explore the subtle but important ideas behind its elegance. Follow this tutorial to create a small, useful Ruby application. As Ruby is primarily an object-oriented language with classes and objects, you can jump right in and create a class to encapsulate behavior. The instructions begin with a simple version of the application, and then expand it. Along the way, you will learn what makes Ruby tick. 
      <br><br>
      The example application will serve two purposes:
      <ol>
        <li>Demonstrate some features of Ruby</li>
        <li>Do something useful in the process</li>
      </ol>
      <br><br>
      A word on the title: Were you to write this code yourself, assuming some moderate Ruby knowledge, it probably wouldn't take more than 10 minutes. Once you learn how Ruby works and understand what sort of code it enables, you'll find that you can whip up useful utilities in short order. Of course, a walk-through of such code will take a bit more than 10 minutes if you're new to the language.
      <br>
      <br>
      <div align="center">
        <table cellspacing="2" cellpadding="2" width="50%" border="1" frame="box" rules="rows">
          <tr>
            <th align="center">What You Need</th>
          </tr>
          <tr>
            <td> This tutorial assumes that you already have a current version of Ruby installed, and you have a code editor handy. You don't need a fancy IDE to code in Ruby; Vim, Emacs, and TextMate are great choices. NetBeans and Eclipse work fine as well.</td>
          </tr>
        </table>
      </div>
      <br>
      <h2>Target Problem: Simplifying File Launching</h2>
      Ruby is primarily a text-based, command-line-oriented language. Some GUI libraries are available, as well as multiple Web application frameworks, but exploring GUI development with Ruby is beyond the scope this article. The goal here is to write something that works from the command line.
      <br
      The example task is simplifying file launching. Given a text file (maybe a Ruby source code file), suppose you want to create a way to launch it in some associated application from the command line. And you want to launch it without having to keep track of file types and application associations. Yes, Windows (and other operating systems) already does this, but your application will have additional features that go beyond this simple behavior. 
      <br><br>
      <h3>Version 0: The Launcher Code</h3>
      First, create a sparse Ruby file. Ruby files end with <code>.rb</code> and have the pivotal line that defines the path to your Ruby interpreter up top. Call the file <code>launcher.rb</code>:
<pre><code>
     #!/usr/bin/env ruby

     # Example application to demonstrate some basic Ruby features
     # This code loads a given file into an associated application

      class Launcher
      end
</code></pre>
      <br>
      Notice you can use a pound sign (#) to start a line-level comment. Everything to the right of the # is hidden from the interpreter. Ruby has a means for commenting multiple lines of code, too. Class names begin with a capital letter; classes are constants, and all Ruby constants start with a capital letter. (For a more complete overview of Ruby syntax, please see "Ruby&#151;A Diamond of a Programming Language?", <a href="http://www.devx.com/enterprise/Article/30917/" target="new">Part 1</a> and <a href="http://www.devx.com/enterprise/Article/31197" target="new">Part 2</a>.)
      <br><br>
      While this code seemingly does nothing, it is executable. If you're playing along at home, you should see that your copy of the code executes. A simple way to run a Ruby script is to simply call the ruby interpreter and pass the name of the file, like this (see <a href="sidebar1.html" name='ref1' id='ref1'>Sidebar 1. Instructions for Executing launcher.rb in Unix and Windows</a>): 

<pre><code>
$ ruby launcher.rb
</code></pre>
      <br>
      When you run the file, you should see nothing&#151;unless there's an error of some sort in the code. So, nothing is good. It doesn't mean nothing is happening; when the ruby interpreter parses your file, it encounters your class definition and makes it available for creating objects. The following code adds the class definition to your code:
<pre><code>
     #!/usr/bin/env ruby

     # Example application to demonstrate some basic Ruby features
     # This code loads a given file into an associated application

      class Launcher
      end

     launcher = Launcher.new
</code></pre>
      <br>
      The code first creates a variable (<code>launcher</code>) that is assigned a reference to a new instance of the class Launcher. You do not have to declare the type of the variable. Ruby uses strong, dynamic typing, and variables can hold references to objects of any type. Pretty much everything in Ruby is an object, including strings, numbers, and regular expressions. Each of these has a formal creation method (e.g., <code>String.new</code>), but Ruby tries to make it easy and fluid to work with the common cases.
      <br><br>
      Second, Ruby creates the object instance by invoking <code>new</code> on your Launcher class. <code>New</code> is a class method; it's analogous to constructor methods in Java. Of course, an empty object won't get you far, so you must add some behavior.
      <br><br>
      <i>Adding Behavior</i><br><br>
      The essence of your application takes a given file name and passes it to an associated application for processing of some sort. The launcher code will need to know how to do this mapping, so when you create an instance of a Launcher class, you must pass in some sort of mapping. You've seen that you can use the class method <code>new</code> to create an instance of a class. To create an instance that starts life with some set of data, you can pass in arguments to <code>new</code>. To handle this, you of course will have to add some code to Launcher:
<pre><code>
  def initialize app_map 
    @app_map = app_map
  end
</code></pre>
      <br>

      You define methods in Ruby using the <code>def</code> keyword, followed by the method name, and then the augment list, if any. The argument list is in parentheses for clarity, though Ruby will allow you to omit them when the meaning of the code is unambiguous (see <a href="#sidebar2"  name='ref2' id='ref2' >Sidebar 2. Why You Add initialize Method When Passing Arguments to <code>new</code> Method</a>).
      <br><br>
      It's worth noting then that Ruby objects begin life with assorted built-in behavior. You can use these as is, or opt to override them.
      <br><br>
      <i>Instance Variables</i><br><br>
      Your initialize method takes one argument, <code>app_map</code>. Again, as with the earlier variable, you do not give the types of method arguments. You just say that the method takes one argument (<code>app_map</code>), and in the body of the method this argument gets assigned to the variable <code>@app_map</code>. The <span class="icode">@</span> symbol indicates that the variable is an instance variable (i.e., it is available to all the code in this object). You create this instance variable when you create your object, and it will be available to any other methods you add to your code.
      <br><br>
      To have your application execute a given file using the associated application, drop some more code into it:
<pre><code>
class Launcher

  def initialize app_map 
    @app_map = app_map
  end

    # Execute the given file using the associate app
    def run file_name 
      application = select_app file_name 
      system "#{application} #{file_name}" )
    end

    # Given a file, look up the matching application
    def select_app file_name 
      ftype = file_type file_name 
      @app_map[ ftype ]
    end

    # Return the part of the file name string after the last '.'
    def file_type file_name 
      File.extname( file_name ).gsub( /^\./, '' ).downcase 
    end

end
</code></pre>
      <br><br>
      The method <code>run</code> takes a file name as its argument, passes it to <code>select_app</code> to find out which application to execute, and then uses Ruby's system method to invoke that application, passing the file name. The <code>system</code> method simply kicks the given command into a sub-shell. While <code>select_app</code> takes the file name, calls <code>file_type</code> to get a 'normalized' file extension, and then uses that as a key into <code>@app_map</code> to see which application to run.
      <br><br>
      Finally, <code>file_type</code> takes the file name and uses a class method on Ruby's File class to get the extension. The string returned by <code>extname</code> includes the period (.) that precedes the file extension. You don't need that, so the code uses <code>gsub</code> (or global substitute) to strip it; it then converts what remains to all lowercase letters with <code>downcase</code>.
      <br><br>
      For compactness, all these method calls are chained together. The string returned from File.extname is the receiver of the <span class="icode">gsub</span> request; the string returned from <span class="icode">gsub</span> then becomes the receiver of the call to <span class="icode">downcase</span>.
      <br><br>
      The example code so far has used objects that you expect to be <span class="icode">String</span>s and <span class="icode">Hash</span>es, but what you really care about is that these objects will respond to particular messages in an appropriate way. (Before delving into how to call your shiny new object, see <a href="#sidebar3"  name='ref3'  id='ref3' >Sidebar 3. A Few Words About Objects, Types, and Behavior</a>.) For such a small application, the subtlety and power of an object system based on messages and run-time behavior may not be critical, but it is important to understand this as you go on to write larger Ruby applications.
      <br><br>
      <h3>Rounding Out Version 0</h3>
      Finish up this first version by putting it to use. You can add the following code to the end of the file to create an instance of Launcher and use it to run an application:
<pre><code>
def help
  print " 
  You must pass in the path to the file to launch.

  Usage: #{__FILE__} target_file
" 
end

if ARGV.empty?
  help
  exit
else
  app_map = {
     'html' => 'firefox',
     'rb' => 'gvim',
     'jpg' => 'gimp'
  }

  l = Launcher.new app_map 
  target = ARGV.join ' ' 
  l.run target 
end
</code></pre>

      <p>You can download this code <a href='/code/10-minutes/v0/launcher.rb'>here</a>.</p>      
      <br>
      The method <span class="icode">help</span> will render instructions if needed. <span class="icode">ARGV</span> is the argument vector; it is a built-in Ruby object that holds all the parameters passed to your program. If it's empty, then your program has nothing to work with, so it displays the help and exits. Otherwise, it creates a hash object and assigns it to the variable <span class="icode">app_map</span>. 
      <br><br>
      The <span class="icode">{ ... }</span> notation is Ruby's literal syntax for creating a <span class="icode">Hash</span> object. You could have used <span class="icode">Hash.new</span>, but it's verbose. Using the literal notation, you map hash keys to values using <span class="icode">=></span>. The hash is used to populate your Launcher instance, while the command-line arguments are collected into a single string stored in the variable <span class="icode">target</span>, which is passed into <span class="icode">run</span>.
      <br><br>
      Before trying this code, you need to change the application values used in <span class="icode">app_map</span> so that they refer to the proper executable. Assuming you have "rb" mapped to a text editor, you can try the code like this:
<pre><code>
$ ruby launcher.rb launcher.rb
</code></pre>
      <br><br>
      This should open your source code in your editor.

      <br><br>

      <h2>Bulking Up to Version 1 with Dynamic Loading</h2>
      So far, so good with Version 0, but you can do better. Rather than having a simple, direct mapping of file types to the application, you could map file types to execution handlers. That is, you can define code for your file types that can then decide which application to run, and with which arguments, depending on additional command-line arguments.
      <br><br>
      For example, if you are doing web development and have created an HTML file, you most often want to view it in a browser. So your application as it is works OK. But sometimes you want to view it using a particular browser. Right now, Launcher only allows a single application association. What you may want is the ability to launch <span class="icode">myfile.html</span> in the Opera web browser:
<pre><code>
$ ./launcher myfile.html opera
</code></pre>
      <br>
      Or you my want to perform some syntax checking on the HTML:
<pre><code>
$ ./launcher myfile.html syntax
</code></pre>
      <br><br>
      In other words, you want to add some smarts (see <a href="#sidebar4"  name='ref4'  id='ref4' >Sidebar 4. The Smarts Behind Launching Logic</a>).
      <br><br>
      <i>Dynamic Loading</i><br>
      To add those smarts, you will change your program so that you can associate file types with Ruby code rather than associating a particular application. That Ruby code will handle the launching logic, allowing you to decide just how clever to be when launching an application for a given file type (see <a href="#sidebar5" name='ref5'  id='ref5' >Sidebar 5. Dynamic Class Loading with Defined Custom Ruby Classes</a>).
      <br><br>
      Before doing this, make one small change. Having all your code in one place is handy, but it's not a good practice for anything but the smallest apps. For the sake of better organization, split out the general class code from the code that interacts with the user. Do this by creating a file, <span class="icode">go.rb</span>, and moving all but the actual Launcher code into that file (i.e, that last chunk of code you just added):
<pre><code>
#!/usr/bin/env ruby

require 'launcher'

# Script to invoke launcher using command-line args
def help
  print " 
  You must pass in the path to the file to launch.

  Usage: #{__FILE__} target_file
" 
end

unless ARGV.size > 0
  help
  exit
else
  app_map = {
     'html' => 'firefox',
     'txt' => 'gvim',
     'jpg' => 'gimp'
  }

  l = Launcher.new app_map 
  target = ARGV.join ' ' 
  l.run target 
end
</code></pre>
      <br>
      Note the extra line of code near the top:
<pre><code>
$:.unshift '.' 
require 'launcher'
</code></pre>
      <br>
      You need these line to make your Launcher available to the current script. 
      <br><br>
      [EDIT: Since Ruby 1.9, ruby does not automatically include the current directory on the require look-up path.  <span class="icode">$:.unshift '.'</span> takes the current folder and adds it to the statr of the array of places your ruby app will look for files to require.]
      <br><br>
      The <span class="icode">require</span> method looks for a file matching the given string. The file extension is omitted, so Ruby first will assume you want a <span class="icode">.rb</span> file but also will look for a compiled library (e.g., <span class="icode">.so</span>) if it doesn't find a Ruby file. (Ruby searches a pre-defined load-path, which includes the current directory, so if you keep launcher.rb in the same place as go.rb, you're good. If you move it, you have to be more explicit about were Ruby can find it.)
      <br><br>
     Downloads: <a href='/code/10-minutes/v1/go.rb'>go.rb</a> and <a href='/code/10-minutes/v1/launcher.rb'>launcher.rb</a>
      <br><br>

      <h3>Writing a Handler Class</h3>
      Now that you have a simple framework for routing file names to Ruby code, create a handler class for HTML files. The class needs to implement a <span class="icode">run</span> method that accepts at least one argument for the target file name, and an optional array of additional parameters. The class name must be Html in a file named <span class="icode">html.rb</span>, and placed in a <span class="icode">handlers</span> subdirectory:
<pre><code>
class Html

  DEFAULT_BROWSER = 'firefox'

  def run file, args
    if args.empty?
      system "#{DEFAULT_BROWSER} #{file}" 
    else
      dispatch_on_parameters file, args
    end
  end

  def dispatch_on_parameters file, args
    cmd = args.shift
    send "do_#{cmd}", file, args 
  end

  def do_opera file, args=nil
    system "opera #{file}  #{args}" 
  end

  def do_konq file, args=nil
    system "konqueror #{file}  #{args}" 
  end
end
</code></pre>
      <br>
      The code defines a constant for a default browser. In the absence of any extra arguments, then, you can have the target file launched in Firefox. (Note that you may have to change this so that it defines an executable command. On my Ubuntu machine I can run <span class="icode">firefox</span> with no explicit path and have a browser come up. On Windows, for example, the full path to the executable may be needed.)
      <br><br>
      If there are additional arguments, <span class="icode">run</span> calls out to <span class="icode">dispatch_on_parameters</span>, which extracts the first item from the args array and uses it to dynamically construct a message string. The <span class="icode">send</span> method is built in to all Ruby objects. It allows you to explicitly send a message to an object. When used by itself (as you are doing here), the receiver object is assumed to be the current object. So the code is sending a message to itself.
      <br><br>
      You prepend <span class="icode">do_</span> to the actual argument value as a safeguard against method name collision. (For example, if the first argument were <span class="icode">exit</span>, you probably would not want to invoke Ruby's <span class="icode">exit</span> method. You'd call <span class="icode">do_exit</span>, which would then decide what the correct behavior should be).
      <br><br>
      This handler code has some fairly trivial examples of possible parameter handling. As is, you can launch a target HTML file in either some default browser or specify a particular browser:
<pre><code>
$ ./go index.html opera
$ ./go index.html konq
</code></pre>
      <br>
      <h2>A Little Overtime for Coolness</h2>
      You've received an educational and practical example, but can you push things a little further? Of course you can. Mind you, this will take you past the 10-minute mark, but it should be worth it.
      <br><br>
      The standard Ruby distribution includes a wealth of libraries for all sorts of tasks. One of the most interesting is REXML, an XML parser written in pure Ruby. Developer Sean Russell wrote REXML to allow the manipulation of XML using a Ruby-style API rather than the usual W3C DOM API. Before too long, Sean's work became part of the Ruby standard library.
      <br><br>
      For the sake of simplicity, your HTML files in this example must use XHTML because REXML handles only XML. (There are very good Ruby tools for processing near-arbitrary HTML, one being <a href="http://code.whytheluckystiff.net/hpricot/" target="new">Hpricot</a>. However, they require installing additional libraries, the explanation of which is beyond the scope of this article.) Trusting that you are working with well-formed XHTML source, you can have your HTML handler do some file analysis. Add this code to the end of your <span class="icode">Html</span> class and you'll be able to run some simple reports on your XHTML:
<pre><code>
  def do_report file, args=nil 
    require 'rexml/document'
    begin 
      dom = REXML::Document.new( IO.read( file ) )
      if args.empty?
        puts basic_xhtml_report( dom )
      else
        puts report_on( dom, args.first )
      end
    rescue Exception
      warn "There was a problem reading '#{file}':\n#{$!}" 
    end
  end

  def report_on dom, element
    els =   dom.root.elements.to_a "//#{element}" 
    "The document has #{els.size} '#{element}' elements" 
  end

  def basic_xhtml_report dom  
    report = []
    css = dom.root.elements.to_a '//link[@rel="stylesheet"]' 
    unless css.empty?
      report &lt;&lt; "The file references #{css.size} stylesheets" 
      css.each do |el|
        file_name = el.attributes['href']
        file_name.gsub! /^\//, ''
        unless File.exist? file_name
          report &lt;&lt; "*** Cannot find stylesheet file '#{file_name}'" 
        end
      end
    end

    js = dom.root.elements.to_a '//script' 
    unless js.empty?
      report &lt;&lt; "The file references #{js.size} JavaScript files" 
      js.each do |el|
        file_name = el.attributes['src']
        file_name.gsub! /^\//, ''
        unless File.exist? file_name
          report &lt;&lt; "*** Cannot find JavaScript file '#{file_name}'" 
        end
      end
    end

    report.join "\n" 
  end
</code></pre>
      <br><br>
      There's a lot going on here, but the key method is <span class="icode">do_report</span>. The code creates a REXML <span class="icode">Document</span> object and assigns it to <span class="icode">dom</span>. If there are no extra arguments, you get back a basic report. Otherwise, the code does some cursory examination of a particular element.
      <br><br>
      The <span class="icode">report_on</span> method takes a document argument and an element name, and uses REXML's XPath features to find out how often that element is used. Although it's rudimentary, it certainly can serve as a demonstration and starting point for you to keep hacking.
      <br><br>
      The <span class="icode">basic_xhtml_report</span> method is similar, but focuses on a particular set of elements. It uses REXML to find all the CSS and JavaScript references, and then uses the File class to check that the referenced files exist. Again, not deep, but adding additional logic makes for a nice project.
      <br><br>
      You can download these files from <a href='/code/10-minutes/v2/'>here</a>, 
<br><br>

      <h3>Clean, Expressive Code with Minimal Scaffolding</h3>
      You now should have a better understanding of some of the features that make Ruby so special, namely:
      <ul>
        <li>Ruby is primarily an object-oriented language, where a key concept is objects responding to messages.</li>
        <li>Ruby uses strong, dynamic typing, where the notion of "type" is based on what an object can do more than on a particular class name or inheritance hierarchy. An object's behavior is not confined to a literal mapping of messages to methods, and behavior may be constructed dynamically at run time.</li>
        <li>Ruby classes are open; you are free to alter their behavior for what you deem appropriate for a given application.</li>
      </ul>
      <br><br>
      This combination of open classes and dynamic behavior enables you to write clean, expressive code with a minimum of boilerplate scaffolding. Ruby gets out of the way and lets you get coding.
      <br>
      <br>


      <div id='sidebar1' title="Instructions for Executing launcher.rb in Unix and Windows">
        <table border="0" cellpadding="5" cellspacing="0">
          <tr>
            <td class="whiteHeader">
              Sidebar 1. Instructions for Executing launcher.rb in Unix and Windows
            </td>
          </tr>
          <tr>
            <td bgcolor="#FFFFFF">
              On Unix systems you can set the file as executable and call it directly:
<pre><code>
$ chmod u+x launcher.rb
$ ./launcher.rb
</code></pre>
              <br>
              Windows users have a leg up here if they used the so-called <a href="http://rubyforge.org/projects/rubyinstaller/" target="new">One-Click Ruby Installer</a>. It takes a few more clicks than one, but in the end it sets up an association for .rb files. So a Windows user should be able to execute the app straight off as follows:
<pre><code>
C:\some\dir> launcher.rb
</code></pre>
              <br>
              However, Windows users should also know that though they can launch a Ruby file by double clicking on it from the Windows file explorer, the results are fleeting: code will execute in a command shell, which will remain visible only so long as the application is running. For the sake of this demonstration, it's best to run the file from a command shell.
              <br>
            </td>
          </tr>
        </table>
        <a class='link-back' href='#ref1'>Back to article</a>
      </div>

      <div id='sidebar2' title='Sidebar 2. Why You Add initialize Method When Passing Arguments to 'new' Method'>

        <table border="0" cellpadding="5" cellspacing="0">
          <tr>
            <td class="whiteHeader">
              Sidebar 2. Why You Add initialize Method When Passing Arguments to 'new' Method
            </td>
          </tr>
          <tr>
            <td bgcolor="#FFFFFF">
              You're probably thinking, <i>why am I adding a method named "initialize" when I want to pass arguments to a method named "new"?</i> The reason has to do with how Ruby creates objects from classes. All classes (such as Launcher) inherit from the class Object, and part of the deal is that the objects they create have a default <span class="icode">initialize</span> method. When the class method <span class="icode">new</span> is called, it first allocates some resources for the desired object, and then invokes the fresh object's <span class="icode">initialize</span> method. If you wish to provide creation parameters via <span class="icode">new</span>, you must define your own <span class="icode">initialize</span> method to handle the arguments in the newly created instance.
            </td>
          </tr>
        </table>
        <a class='link-back' href='#ref2'>Back to article</a>
      </div>
      <div id='sidebar3' title='Sidebar 3. A Few Words About Objects, Types, and Behavior'>

        <table border="0" cellpadding="5" cellspacing="0">
          <tr>
            <td  class="whiteHeader">
              Sidebar 3. A Few Words About Objects, Types, and Behavior
            </td>
          </tr>
          <tr>
            <td bgcolor="#FFFFFF">
              Ruby follows a message-passing model of object-oriented programming. When you see code like <code>foo.bar</code>, it means that the message "bar" is being passed to the object referenced by <span class="icode">foo</span>. Most of the time, that object will have a method <span class="icode">bar</span>, and when you see such code you may be tempted to think of it as calling <span class="icode">foo</span>'s <span class="icode">bar</span> method. However, while that is convenient (and common), it is important to know what's happening under the hood.
              <br><br>
              When an object receives a message, it first looks for a corresponding method. The search will work its way up the inheritance hierarchy*, starting with the object's own class, until it reaches the <span class="icode">Object</span> class. If no match is found, then the method <span class="icode">method_missing</span> is called. As you may have guessed, there's a default implementation of <span class="icode">method_missing</span>, and it does nothing more than raise an exception. But just as you were able to override the default definition of initialize, you also can alter <span class="icode">method_missing</span>. You are free to redefine it so your object might apply some smarts to handling arbitrary message requests, making it appear that the object implements many more methods than it actually does.
              <br><br>
              This flexibility is at the core of one of the most appealing aspects of Ruby, but it also points to an important aspect that may trouble some people. You've seen that you do not declare data types when creating variables or defining method argument lists. If you want to check data types, you can. Code <i>can</i> ask for an object's type, and act accordingly. For example, you may want to write a method that accepts either a file name (e.g., a <span class="icode">String</span> object ) or a file handle (e.g., a <span class="icode">File</span> object). But Ruby code rarely checks an object's type simply for defensive measures, refusing to continue unless given an object that asserts itself to be a certain type. Because classes and objects are mutable at run-time, the notion of type in Ruby is essentially defined as the <i>behavior</i> of an object at any given time. Type is defined by which methods an object responds to, not which class it comes from. As Rubyist Logan Capaldo once said, "In Ruby, no one cares who your parents were. All they care about is if you know what you are talking about."
              <br><br>
              The general term for this is <i>duck typing</i>, from the phrase, "If it walks like a duck and quacks like a duck, then it's a duck."
              <br><br>
              <hr>
              * Note: This is not quite true; inheritance is but one way an object can obtain some behavior. For a better explanation of how Ruby decides what to do when an object is given a message, watch Patrick Farley at MountainWest RubyConf 2008 explain <a href='http://mtnwestrubyconf2008.confreaks.com/11farley.html' >Ruby internals</a>. 
              <br>In fact, watching this talk should be one of your next steps in learning Ruby; metaprogamming tends to have a weird, mysterious aura around it, as if it were only something for Ruby gurus.  Truth is, if you understand a few core properties of Ruby objects you too can be a metaprogramming master.
            </td>
          </tr>
        </table>

        <a class='link-back'  href='#ref3'>Back to article</a>

      </div>

      <div id='sidebar4' title='Sidebar 4. The Smarts Behind Launching Logic'>

        <table border="0" cellpadding="5" cellspacing="0">
          <tr>
            <td class="whiteHeader">
              Sidebar 4. The Smarts Behind Launching Logic
            </td>
          </tr>
          <tr>
            <td bgcolor="#FFFFFF">
              Where you were mapping a file extension to a particular application name, you now want to add associations with Ruby code. Specifically, you want Ruby classes custom-coded for each type of file you want to process.
              <br><br>
              First, create a new Ruby source file named launcherx.rb (the x is for extended) in the directory as launcher.rb:
<pre><code>
#!/usr/bin/env ruby
# File launcherx.rb
require 'launcher'

class Launcher
  def handler file 
    get_handler(file) || build_handler(file)
  end
  
  def build_handler file 
    handler = Class.new 
    application = select_app file
    eval "def handler.run file,  args=nil
      system '#{application} \#{file} \#{args}'  
    end"
    handler
  end

  def get_handler file
    begin
      here = File.expand_path( File.dirname __FILE__  )
      ftype = file_type file
      require "#{here}/handlers/#{ftype }"
      Object.const_get( ftype.capitalize ).new
    rescue Exception
      nil
    end
  end

  # Execute the given file using he associate app
  def run file, args = nil 
    handler(file).run file, args
  end
end

</code></pre>
              <br><br>
              The first thing to note is that the code is calling <span class="icode">require</span> to load the existing definition of Launcher. Yet your new code also defines a class named Launcher. What gives? When Ruby encounters a class definition that uses the name of an existing class, it updates the existing class with the new class. The methods defined in your first version of Launcher are still there; new methods defined in the additional code get added. And, as in the case of <span class="icode">run</span>, when new code uses the same name as existing code, the new code replaces the old. The upshot of this is that you do not have to duplicate the code from your first version; you need only add to or modify it.
              <br><br>
              [EDIT: In going through the code I found that the original version of <span class="icode">build_handler</span> didnot escape the use of string interpolation.  Here's what that means: Ruby allows you to create strings that contain evaluated bits of Ruby code. For example, "Today is #{Time.now}",  will, when evaluated by Ruby, contain the date at the time of execution.  The stuff inside of <span class="icode">#{ ... }</span> is first evaluated before being placed into the resulting string. <br><br>
              Now: Suppose you want to create a string that contains Ruby code that can be used (at a later date) for string interpolation? What <span class="icode">build_handler</span> is to doing is dynamically generating code for a method to be used at some later time.  That code needs to contain some string interpolation.  The trick is to embed <span class="icode">#{ ... }</span> in such a way that it is not immediately evaluated (when we are first dynamically creating the method code).  THe way to do that is to <em>escape</em> the leading hash character using a backslash: <span class="icode">\#{ ... }</span>.<br><br>
              The original version did not do this.  The code worked more or less coincidentally, given the artificial use-case for this article.  The first version ended up hard-coding specific values for <span class="icode">file</span> and <span class="icode">args</span>. 
              However, if <span class="icode">build_handler</span> is passed, for example, 'html', then thre generated methods should be something like 

<pre>
    def handler.run file,  args=nil
      system 'firefox  #{file} #{args}'  
   end
</pre>
      
              ]
              <br><br>
              Not so incidentally, this also works on core Ruby classes. For example, you can add to or alter the behavior of <span class="icode">String</span> by defining a <span class="icode">String</span> class with your own methods. If your code is frequently altering strings (perhaps to replace special characters), you can make your code clearer with something like this:
<pre><code>
class String
  def amp_escape
    self.gsub '&amp;', '&amp;amp;' 
  end
end

</code></pre>
              <br><br>
              Which then enables your code to do this:
<pre><code>
"This &amp; that".amp_escape
</code></pre>
              <br><br>
              Your new application file now needs to handle the new behavior. The <span class="icode">run</span> method changes because this new version will be invoking Ruby code instead of directly calling a shell command, and you want the option of passing in additional arguments. Therefore, this version expects a file name and an optional array of arguments. It's optional because in the methods argument list you're giving it a default value of nil. Arguments pre-assigned this way must always come last in the argument list.
              <br><br>
              Whereas your first version simply used the file extension to pull an application name from a hash, this code uses <span class="icode">handler</span> to create a corresponding Ruby class to handle the given file name. The <span class="icode">handler</span> method is short; it first calls <span class="icode">get_handler</span> to see if it can locate a matching handler class. The <span class="icode">||</span> method is Ruby's logical OR. Should <span class="icode">get_handler</span> return <span class="icode">false</span> (or <span class="icode">nil</span>, which Ruby treats as <span class="icode">false</span>), then the code to the right of <span class="icode">||</span> is invoked. If there is no defined handler class, then the code makes one.
              <br><br>
              Recall that your new version of <span class="icode">run</span> will expect <span class="icode">get_handler</span> to return an object that responds to the <span class="icode">run</span> message. The <span class="icode">build_handler</span> method therefore needs to define a class with this behavior. There are a variety of ways you could do this. Here, you're going to first create a generic instance of the class <span class="icode">Class</span> and then dynamically add a <span class="icode">run</span> method that knows how to handle the particular file type in question.
              <br><br>
              Your new Launcher class retained the application map code from the original. This mapping serves as a fallback for handling files in the absence of any special Ruby code, meaning that your new version still does what the first version did. Your code can still call <span class="icode">select_app</span> to get the default application. The trick now is to get that into a method on your new class.
              <br><br>
              Perhaps the simplest way to do this is to build a string with the code you might write if you <i>did</i> know which application to invoke. You then have Ruby <span class="icode">eval</span> (i.e., evaluate) this string, making it part of the current process. (Note: capricious use of <span class="icode">eval</span> on arbitrary strings is not wise. It works well for the sample application and helps demonstrate an interesting feature of Ruby, but use it with care in more serious applications--especially any code that allows input from users.)
              <br><br>
              Just like that, <span class="icode">build_handler</span> can now return an object (albeit sparse) that knows how to do the one thing that matters: respond to a <span class="icode">run</span> request.
              <br><br>
            </td>
          </tr>
        </table>
        <a class='link-back' href='#ref4'>Back to article</a>
      </div>

      <div id='sidebar5' title='Sidebar 5. Dynamic Class Loading'>
        <table border="0" width="510" cellpadding="5" cellspacing="0">
          <tr>
            <td class="whiteHeader">
              Sidebar 5. Dynamic Class Loading
            </td>
          </tr>
          <tr>
            <td bgcolor="#FFFFFF">
              The real fun is in defining custom Ruby classes that have more interesting implementations of <span class="icode">run</span>. First, assume all these classes will live in files named after the file extension they handle. For example, a handler class designed to process HTML files will go into a file named <span class="icode">html.rb</span>. Also, all such files will go into a relative subdirectory named <span class="icode">handlers</span>. Asserting these two conventions allows the <span class="icode">get_handler</span> code to know just what to look for and where to look for it, bypassing a need for lengthy configuration settings.
              <br><br>
              When <span class="icode">get_handler</span> is called, it:
              <ol>
                <li>Uses some built-in <span class="icode">File</span> methods to figure out the current file-path location (<span class="icode">__FILE__</span> is a special Ruby variable that refers to the actual file containing the current code).</li>
                <li>Appends your pre-defined handlers directory to the current path.</li>
                <li>Uses the file extension of the target file name to derive the name of the file holding the handler class code.</li>
              </ol>
              <br>
              All of this is passed to <span class="icode">require</span> with the expectation that such a file exists and that it will be loaded. If all goes well, Ruby will load and parse this file, making the desired class available to your code.
              <br><br>
              Now, without knowing the name of the class you want to instantiate in advance, you again need to do a bit of dynamic invocation. You could again use <span class="icode">eval</span>, but you can also reach into Ruby's list of constants (remember, classes are Ruby constants) and call <span class="icode">new</span>. Again, if all has gone well, <span class="icode">Object.const_get</span> will return the class desired, and <span class="icode">new</span> will then return an instance.
              <br><br>
              Should something go wrong (perhaps there is no such file to load, or the code in the file is malformed) and Ruby raises an exception, the code uses <span class="icode">rescue</span> to handle things. You could use <span class="icode">rescue</span> with more specific exceptions for more targeted error handling, but for the purposes of this example, you simply want to trap all exceptions and quietly return <span class="icode">nil</span>.
              <br><br>
              You may have noticed that <span class="icode">get_handler</span> does not explicitly specify which value to return. Indeed, none of your methods have done so. In Ruby, the return value of a method (with some exceptions) is the value of the last expression executed. <span class="icode">get_handler</span> has one top-level expression: <span class="icode">begin/rescue/end</span>. Its value will be either the value of the last expression in the <span class="icode">begin/rescue</span> section or the value created in <span class="icode">rescue/end</span>. Ruby does define <span class="icode">return</span>, which exits a method returning the provided value, but method flow control is sufficient to define an unambiguous return in most cases.
              <br>
            </td>
          </tr>
        </table>
        <a  class='link-back'  href='#ref5'>Back to article</a>
      </div>
      
      <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'neurogami'; 

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>


      <div class='clear'></div>
      <div class='grids'>This article was originally published on <a href='http://www.devx.com/RubySpecialReport/Article/34502/1954'>DevX.com</a></div>
    </div>


 
        <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'neurogami'; 

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>


      </div>
      <div class='gap'>&#160;</div>
      <div class='footer grids'><div class='grid-12'>
  
    <a id='switch-default-css' href="#" onclick="setActiveStyleSheet('default'); return false;">CSS</a> <a  id='switch-mono-css' href="#" onclick="setActiveStyleSheet('mono'); return false;">CSS</a><span class='dotty'>&#8901;</span><h1>Neurogami</h1><span class='dotty'>&#8901;</span><h2>Avant-garage research + development</h2><span class='dotty'>&#8901;</span> (480) 236 4136<span class='dotty'>&#8901;</span>  <a class="stark plain notice" href="http://twitter.com/Neurogami">@neurogami</a><span class='dotty'>&#8901;</span>&#169; 2012 Neurogami<span class='dotty'>

 </div>

<script type="text/javascript">
  /*
  $(document).ready(function() { 
	$("#styles li a").click(function() { 
    $("#css").attr("href",$(this).attr('rel'));
		return false;
    });

	$("#cssMono").click(function() { 
    $("#css").attr("href", "/css/mono.css");
		return false;
	});
  });
  */
</script>
</div>

    </div>
    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-29014637-1']);
      _gaq.push(['_setDomainName', 'neurogami.com']);
      _gaq.push(['_trackPageview']);

      (function() {
       var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
       ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
       var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
       })();

     </script>
     <script  type="text/javascript" src='http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js' ></script>

<script type="text/javascript">

  $( document ).ready( function() {
      var $body = $('body'); //Cache this for performance

      var setBodyScale = function() {
      var scaleSource = $body.width(),
      scaleFactor = 0.12,                     
      maxScale = 1200,
      minScale = 10; //Tweak these values to taste

      var fontSize = scaleSource * scaleFactor; //Multiply the width of the body by the scaling factor:

      if (fontSize > maxScale) fontSize = maxScale;
      if (fontSize < minScale) fontSize = minScale; //Enforce the minimum and maximums

      $('body').css('font-size', fontSize + '%');
      }

      $(window).resize(function(){
        setBodyScale();
        });

      //Fire it when the page first loads:
      setBodyScale();
  });

</script>
 
   </body>
 </html>



